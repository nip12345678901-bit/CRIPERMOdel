<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CRISPR 3D — Single File Working</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:#f6f7fb}
    #panel{position:absolute;left:12px;top:72px;width:280px;background:#fff;padding:12px;border-radius:8px;z-index:90;box-shadow:0 8px 24px rgba(10,20,40,0.08)}
    #controls{position:absolute;left:12px;bottom:12px;width:460px;background:#fff;padding:10px;border-radius:8px;z-index:90;box-shadow:0 8px 24px rgba(10,20,40,0.08)}
    #enzyme{width:100%;height:44px;background:#6b5b95;color:#fff;display:flex;align-items:center;justify-content:center;border-radius:6px;cursor:grab;user-select:none;margin-top:8px;position:relative}
    .btn{margin-top:8px;padding:8px;border-radius:6px;border:0;cursor:pointer;font-weight:600}
    .btn.red{background:#e74c3c;color:#fff}
    .btn.gray{background:#95a5a6;color:#fff}
    canvas{display:block;position:fixed;left:0;top:0;z-index:1}
    #mutList{max-height:120px;overflow:auto;margin-top:8px;padding-left:14px}
    #lastRepair{font-size:13px;margin-top:8px;color:#0f172a}
    @media (max-width:900px){ #panel{width:220px} #controls{width:320px} }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
  <div id="panel" role="region" aria-label="Controls">
    <div style="font-weight:700;margin-bottom:6px">Enzyme</div>
    <select id="casSelect" style="width:100%;padding:8px;border-radius:6px;border:1px solid #e6e9ef">
      <option value="Cas9">Cas9</option>
      <option value="dCas9">dCas9</option>
      <option value="Cas12">Cas12</option>
    </select>
    <div id="enzyme">Cas9</div>

    <div style="margin-top:8px">
      <label style="font-size:13px">Guide (min 4 nt)</label>
      <input id="guideInput" type="text" maxlength="40" placeholder="ATCG..." style="width:100%;margin-top:6px;padding:8px;border-radius:6px;border:1px solid #e6e9ef">
      <div style="margin-top:6px;display:flex;gap:6px">
        <button id="loadGuide" class="btn gray" style="flex:1">Load Guide</button>
        <button id="findPAM" class="btn gray" style="flex:1">Find PAMs</button>
      </div>
    </div>

    <div style="margin-top:10px;display:flex;gap:8px">
      <button id="simCut" class="btn red" style="flex:1">Simulate Cut (Space)</button>
      <button id="resetBtn" class="btn gray" style="flex:1">Reset DNA</button>
    </div>

    <div id="lastRepair">Last repair: —</div>
    <div style="margin-top:10px">
      <strong>Mutations</strong>
      <ul id="mutList"></ul>
    </div>
  </div>

  <div id="controls">
    <div style="display:flex;gap:8px;align-items:center">
      <button id="btnNHEJ" class="btn gray">Simulate NHEJ</button>
      <button id="btnHDR" class="btn gray">Simulate HDR</button>
      <button id="btnPause" class="btn gray">Pause</button>
    </div>
    <div style="margin-top:8px;display:flex;align-items:center;gap:8px">
      <label style="font-size:13px">Speed</label>
      <input id="speed" type="range" min="0" max="2" step="0.05" value="1" style="flex:1">
    </div>
    <div style="margin-top:8px;font-size:13px">
      <strong>Guide:</strong> <span id="guide2d" style="font-family:monospace;background:#f3f4f6;padding:4px;border-radius:4px;cursor:pointer">—</span>
    </div>
  </div>

  <script>
  (function(){
    'use strict';
    if (typeof THREE === 'undefined') { document.body.innerHTML = '<div style="padding:20px">Three.js failed to load.</div>'; return; }

    // --- Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf6f7fb);
    const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 5000);
    camera.position.set(0, 120, 700);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(200,400,200); scene.add(dir);

    // --- DNA data + helpers
    let pairCount = 40;
    const helixRadius = 120, pitch = 6, angleStep = 0.45;
    const dna = [];
    const colors = { A:0xe74c3c, T:0x2ecc71, C:0x3498db, G:0xf1c40f, '-':0x999999 };
    const sphereGeo = new THREE.SphereGeometry(8,12,12);
    const dnaGroup = new THREE.Group(); scene.add(dnaGroup);

    function complement(b){ if(b==='A')return'T'; if(b==='T')return'A'; if(b==='C')return'G'; if(b==='G')return'C'; return'N'; }
    function randomGuide(len){ const b=['A','T','C','G']; let s=''; for(let i=0;i<len;i++) s+=b[Math.floor(Math.random()*4)]; return s; }

    // UI refs
    const enzymeEl = document.getElementById('enzyme');
    const guideInput = document.getElementById('guideInput');
    const guide2dEl = document.getElementById('guide2d');
    const lastRepairEl = document.getElementById('lastRepair');
    const mutListEl = document.getElementById('mutList');

    // state
    let guideSeq = randomGuide(20);
    guide2dEl.innerText = guideSeq;
    guideInput.value = guideSeq;
    let attachedIndex = -1;
    const cutSites = [];

    // generate DNA
    function generateDNA(){
      // clear
      while(dnaGroup.children.length) { const c = dnaGroup.children[0]; dnaGroup.remove(c); if (c.geometry) c.geometry.dispose && c.geometry.dispose(); if (c.material) c.material.dispose && c.material.dispose(); }
      dna.length = 0; mutListEl.innerHTML = ''; cutSites.length = 0;

      for (let i=0;i<pairCount;i++){
        const a = ['A','T','C','G'][Math.floor(Math.random()*4)];
        const b = complement(a);
        const theta = i * angleStep;
        const x = Math.cos(theta) * helixRadius;
        const z = Math.sin(theta) * helixRadius;
        const y = (i - pairCount/2) * pitch;

        const matA = new THREE.MeshStandardMaterial({ color: colors[a] });
        const matB = new THREE.MeshStandardMaterial({ color: colors[b] });
        const meshA = new THREE.Mesh(sphereGeo, matA);
        const meshB = new THREE.Mesh(sphereGeo, matB);
        meshA.position.set(x-12,y,z);
        meshB.position.set(x+12,y,z);
        dnaGroup.add(meshA); dnaGroup.add(meshB);

        const connGeo = new THREE.BufferGeometry().setFromPoints([ meshA.position.clone(), meshB.position.clone() ]);
        const conn = new THREE.Line(connGeo, new THREE.LineBasicMaterial({ color: 0xcccccc }));
        dnaGroup.add(conn);

        dna.push({ index:i, a, b, meshA, meshB, conn, posA:meshA.position.clone(), posB:meshB.position.clone(), pam:false, pamRing:null, guideRing:null });
      }

      // mark PAMs (NGG/NAG) on center base of triads
      for (let i=0;i<dna.length-2;i++){
        const tri = dna[i].a + dna[i+1].a + dna[i+2].a;
        if (/.[G][G]/.test(tri) || /.[A][G]/.test(tri)){
          const mid = new THREE.Vector3().addVectors(dna[i+1].posA, dna[i+1].posB).multiplyScalar(0.5);
          const ringGeo = new THREE.RingGeometry(18,22,32);
          const color = /.[G][G]/.test(tri) ? 0xff6b6b : 0xf39c12;
          const ringMat = new THREE.MeshBasicMaterial({ color, side:THREE.DoubleSide, transparent:true, opacity:0.9 });
          const ring = new THREE.Mesh(ringGeo, ringMat);
          ring.position.copy(mid); ring.rotation.x = Math.PI/2;
          dnaGroup.add(ring); dna[i+1].pam = true; dna[i+1].pamRing = ring;
        }
      }

      lastRepairEl.innerText = 'DNA generated (' + pairCount + ' pairs)';
    }

    generateDNA();

    // raycaster + hover
    const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2(); let hoverIndex = -1;
    window.addEventListener('pointermove', (e)=>{
      mouse.x = (e.clientX/window.innerWidth)*2-1; mouse.y = -(e.clientY/window.innerHeight)*2+1;
      raycaster.setFromCamera(mouse, camera);
      const objects = dna.flatMap(d=>[d.meshA,d.meshB]);
      const hits = raycaster.intersectObjects(objects, false);
      if (hits.length){
        const hit = hits[0].object;
        const idx = dna.findIndex(d => d.meshA===hit || d.meshB===hit);
        if (idx !== hoverIndex){
          if (hoverIndex>=0){ dna[hoverIndex].meshA.material.emissive.setHex(0x000000); dna[hoverIndex].meshB.material.emissive.setHex(0x000000); }
          hoverIndex = idx;
          dna[hoverIndex].meshA.material.emissive.setHex(0x333333); dna[hoverIndex].meshB.material.emissive.setHex(0x333333);
        }
      } else {
        if (hoverIndex>=0){ dna[hoverIndex].meshA.material.emissive.setHex(0x000000); dna[hoverIndex].meshB.material.emissive.setHex(0x000000); }
        hoverIndex = -1;
      }
    });

    // enzyme 3D marker
    const enzymeGroup = new THREE.Group();
    const enzymeBody = new THREE.Mesh(new THREE.SphereGeometry(14,16,16), new THREE.MeshStandardMaterial({ color:0x6b5b95 }));
    enzymeGroup.add(enzymeBody);
    scene.add(enzymeGroup);

    // UI drag & snap
    let draggingUI = false;
    enzymeEl.addEventListener('pointerdown', (ev)=>{
      draggingUI = true; enzymeEl.setPointerCapture && enzymeEl.setPointerCapture(ev.pointerId); enzymeEl.style.cursor='grabbing';
    });
    window.addEventListener('pointermove', (ev)=>{
      if (!draggingUI) return;
      enzymeEl.style.left = (ev.clientX - 45) + 'px'; enzymeEl.style.top = (ev.clientY - 20) + 'px'; enzymeEl.style.position='absolute'; enzymeEl.style.zIndex='99999';
    });
    window.addEventListener('pointerup', (ev)=>{
      if (!draggingUI) return;
      draggingUI = false; enzymeEl.style.cursor='grab';
      const mx = (ev.clientX/window.innerWidth)*2-1; const my = -(ev.clientY/window.innerHeight)*2+1;
      raycaster.setFromCamera({x:mx,y:my}, camera);
      const hits = raycaster.intersectObjects(dna.flatMap(d=>[d.meshA,d.meshB]), false);
      if (hits.length){
        const hit = hits[0].object;
        const idx = dna.findIndex(d => d.meshA===hit || d.meshB===hit);
        if (idx >= 0){
          attachedIndex = idx;
          const p = new THREE.Vector3().addVectors(dna[idx].posA, dna[idx].posB).multiplyScalar(0.5);
          enzymeGroup.position.copy(p);
          const screen = worldToScreen(p);
          enzymeEl.style.left = (screen.x - 45) + 'px'; enzymeEl.style.top = (screen.y - 20) + 'px';
          lastRepairEl.innerText = 'Enzyme bound @ ' + idx;
          return;
        }
      }
      // return to sidebar
      attachedIndex = -1;
      enzymeEl.style.position='relative'; enzymeEl.style.left=''; enzymeEl.style.top=''; enzymeEl.style.zIndex='';
      lastRepairEl.innerText = 'Enzyme returned';
    });

    function worldToScreen(vec){
      const v = vec.clone(); v.project(camera);
      return { x:(v.x+1)*innerWidth/2, y:(-v.y+1)*innerHeight/2 };
    }

    // cut / repair
    function addMutationEntry(entry){
      if (!mutListEl) return;
      const li = document.createElement('li');
      li.textContent = `${entry.type} @ ${entry.index} ${entry.offTarget? '(off-target)':''} ${new Date(entry.time).toLocaleTimeString()}`;
      mutListEl.prepend(li);
    }

    function performCut(idx){
      if (idx < 0) return;
      if (!dna[idx]) return;
      dna[idx].meshA.material.color.setHex(colors['-']); dna[idx].meshB.material.color.setHex(colors['-']);
      dna[idx].a = '-'; dna[idx].b = '-';
      cutSites.push(idx);
      addMutationEntry({type:'cut', index:idx, offTarget:!dna[idx].pam, time:Date.now()});
      lastRepairEl.innerText = 'Cut at ' + idx;
      enzymeEl.style.position='relative'; enzymeEl.style.left=''; enzymeEl.style.top=''; attachedIndex=-1;
    }

    function simulateNHEJ(){
      if (!cutSites.length){ alert('No cut to repair'); return; }
      const idx = cutSites[cutSites.length-1];
      const del = Math.floor(Math.random()*2);
      const ins = Math.floor(Math.random()*2);
      for (let i=0;i<del;i++){ const p = Math.min(dna.length-1, idx+i); dna[p].meshA.material.color.setHex(colors['-']); dna[p].meshB.material.color.setHex(colors['-']); dna[p].a='-'; dna[p].b='-'; addMutationEntry({type:'del', index:p, offTarget:false, time:Date.now()}); }
      for (let i=0;i<ins;i++){ const p = Math.min(dna.length-1, idx+1+i); const base = ['A','T','C','G'][Math.floor(Math.random()*4)]; dna[p].meshA.material.color.setHex(colors[base]); dna[p].meshB.material.color.setHex(colors[complement(base)]); dna[p].a=base; dna[p].b=complement(base); addMutationEntry({type:'ins', index:p, offTarget:false, time:Date.now()}); }
      lastRepairEl.innerText = 'NHEJ at ' + idx;
    }

    function simulateHDR(donor){
      if (!cutSites.length){ alert('No cut to repair'); return; }
      const idx = cutSites[cutSites.length-1];
      if (!donor){ donor = prompt('Enter donor sequence (A/T/C/G):','ATCG'); if (!donor) return; }
      donor = donor.toUpperCase().replace(/[^ATCG]/g,'').slice(0, dna.length);
      for (let i=0;i<donor.length;i++){
        const pos = Math.min(dna.length-1, idx - Math.floor(donor.length/2) + i);
        const base = donor[i]; dna[pos].meshA.material.color.setHex(colors[base]); dna[pos].meshB.material.color.setHex(colors[complement(base)]); dna[pos].a=base; dna[pos].b=complement(base);
        addMutationEntry({type:'HDR', index:pos, offTarget:false, time:Date.now()});
      }
      lastRepairEl.innerText = 'HDR at ' + idx;
    }

    // guide highlight
    function highlightGuide(seq){
      if (!seq) return;
      for (let i=0;i<dna.length;i++){ if (dna[i].guideRing){ dnaGroup.remove(dna[i].guideRing); dna[i].guideRing = null; } }
      const aStr = dna.map(d=>d.a).join('');
      const idx = aStr.indexOf(seq);
      if (idx >= 0){
        for (let i=idx;i<idx+seq.length && i<dna.length;i++){
          const ringGeo = new THREE.RingGeometry(14,18,32);
          const ringMat = new THREE.MeshBasicMaterial({ color:0x2ecc71, side:THREE.DoubleSide, transparent:true, opacity:0.9 });
          const ring = new THREE.Mesh(ringGeo, ringMat);
          const mid = new THREE.Vector3().addVectors(dna[i].posA, dna[i].posB).multiplyScalar(0.5);
          ring.position.copy(mid); ring.rotation.x = Math.PI/2; dnaGroup.add(ring); dna[i].guideRing = ring;
        }
        lastRepairEl.innerText = 'Guide found @ ' + idx;
      } else lastRepairEl.innerText = 'Guide not found';
    }

    // UI wiring
    document.getElementById('simCut').addEventListener('click', ()=>{ if (attachedIndex>=0) performCut(attachedIndex); else alert('Drag enzyme to a base pair first'); });
    document.getElementById('btnNHEJ').addEventListener('click', simulateNHEJ);
    document.getElementById('btnHDR').addEventListener('click', ()=>simulateHDR());
    document.getElementById('resetBtn').addEventListener('click', ()=>{ generateDNA(); });
    document.getElementById('loadGuide').addEventListener('click', ()=>{
      const v = (guideInput.value||'').toUpperCase().replace(/[^ATCG]/g,'');
      if (!v || v.length < 4){ alert('Enter a valid guide (min 4 bases)'); return; }
      guideSeq = v; guide2dEl.innerText = guideSeq; highlightGuide(guideSeq);
    });
    document.getElementById('findPAM').addEventListener('click', ()=>{
      const counts = dna.reduce((acc,d)=>{ if (d.pam) acc++ ; return acc; }, 0);
      alert('PAM count: ' + counts);
    });
    document.getElementById('casSelect').addEventListener('change', function(){ enzymeEl.innerText = this.value; enzymeBody.material.color.setHex(this.value==='Cas12'?0x16a085:0x6b5b95); });

    window.addEventListener('keydown', function(e){ if (e.code==='Space'){ e.preventDefault(); if (attachedIndex>=0) performCut(attachedIndex); else alert('Drag enzyme to a base pair first'); } });

    // animation loop
    let running = true; const speedEl = document.getElementById('speed'); let speed = 1;
    document.getElementById('btnPause').addEventListener('click', function(){ running = !running; this.innerText = running ? 'Pause' : 'Resume'; });
    speedEl.addEventListener('input', ()=>{ speed = parseFloat(speedEl.value||'1'); });

    let last = performance.now();
    function animate(now){
      requestAnimationFrame(animate);
      const dt = (now - last) * 0.001 * speed; last = now;
      if (running) dnaGroup.rotation.y += 0.5 * dt;
      controls.update && controls.update();
      renderer.render(scene, camera);
    }
    animate(performance.now());

    // resize
    window.addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

    // expose debug
    window.__dnaState = { scene, camera, renderer, dna, dnaGroup, attachedIndexGetter: ()=> attachedIndex, performCut, generateDNA };

    // final log
    lastRepairEl.innerText = 'Ready — guide: ' + guideSeq;
  })();
  </script>
</body>
</html>
